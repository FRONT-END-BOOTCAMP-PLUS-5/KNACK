'use client'

import { useEffect, useMemo, useState } from 'react'
import { loadTossPayments } from '@tosspayments/payment-sdk'
import styles from './CheckoutPage.module.scss'
import AddressBox from '@/components/address/AddressBox'
import requester from '@/utils/requester'
import PaymentFooter from '@/components/Payments/PaymentFooter'
import OrderSummaryCard from '@/components/Payments/Order/OrderSummaryCard'
import PointSection from '@/components/Payments/Points'
import FinalOrderSummary from '@/components/Payments/Order/FinalOrderSummary'
import { AddressDto } from '@/backend/address/applications/dtos/AddressDto'
import { IProduct } from '@/types/product'
import AddressModal from '@/components/address/AddressModal'
import { formatFullAddress } from '@/utils/openKakaoPostCode'
import RequestModal from '@/components/address/RequestModal'
import { AddressDtoWithPostalFields, CheckoutRow, OrderItem } from '@/types/order'

const TOSS_CLIENT_KEY = process.env.NEXT_PUBLIC_TOSS_CLIENT_KEY!

export default function CheckoutPage() {
    // ----- Local UI States (Zustand Ï†úÍ±∞) -----
    const [checkout, setCheckout] = useState<CheckoutRow[]>([])
    const [orderItems, setOrderItems] = useState<OrderItem[]>([])
    const [deliveryType, setDeliveryType] = useState<'FAST' | 'STOCK'>('FAST')
    const [deliveryFee, setDeliveryFee] = useState<number>(5000)
    const [points, setPoints] = useState<number>(0) // ÏÇ¨Ïö© Ìè¨Ïù∏Ìä∏
    const [selectedAddress, setSelectedAddress] = useState<{
        id: number
        name: string
        phone: string
        fullAddress: string
        request: string
        postalCode?: string;
    } | null>(null)
    const [isAddressModalOpen, setIsAddressModalOpen] = useState(false)
    const [isReqOpen, setReqOpen] = useState(false);

    // ----- delivery controls -----
    const onChangeDelivery = (type: 'FAST' | 'STOCK') => {
        setDeliveryType(type)
        setDeliveryFee(type === 'FAST' ? 5000 : 0)
    }

    // ----- totals -----
    const priceWithoutDelivery = useMemo(
        () => orderItems.reduce((sum, it) => sum + it.price * it.quantity, 0),
        [orderItems]
    )
    const couponAmount = 0 // Ïø†Ìè∞ ÎèÑÏûÖ Ïãú ÍµêÏ≤¥
    const totalBeforePoints = useMemo(
        () => Math.max(0, priceWithoutDelivery + deliveryFee - couponAmount),
        [priceWithoutDelivery, deliveryFee, couponAmount]
    )
    const totalPrice = useMemo(
        () => Math.max(0, totalBeforePoints - points),
        [totalBeforePoints, points]
    )

    // ----- save request message -----
    const handleSaveRequestMessage = async () => {
        if (!selectedAddress?.id) {
            alert('Ï£ºÏÜåÍ∞Ä ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.')
            return
        }
        try {
            await requester.patch(`/api/addresses/${selectedAddress.id}/message`, {
                requestMessage: selectedAddress.request,
            })
        } catch (e) {
            console.error('ÏöîÏ≤≠ÏÇ¨Ìï≠ Ï†ÄÏû• Ïã§Ìå®', e)
            alert('ÏöîÏ≤≠ÏÇ¨Ìï≠ Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.')
        }
    }

    // ----- payment -----
    const handlePayment = async () => {
        if (!orderItems.length) return alert('ÏÉÅÌíàÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.')
        if (!selectedAddress) return alert('Ï£ºÏÜåÏßÄÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.')

        try {
            await handleSaveRequestMessage()

            const toss = await loadTossPayments(TOSS_CLIENT_KEY)
            console.log(toss);
            await toss.requestPayment('Ïπ¥Îìú', {
                amount: totalPrice,
                orderId: `order_${Date.now()}`, // Í∂åÏû•: ÏÑúÎ≤ÑÏóêÏÑú ÏÑ†Î∞úÍ∏âÌïú orderNumber ÏÇ¨Ïö©
                orderName: `${orderItems[0]?.kor_name || orderItems[0]?.eng_name || 'ÏÉÅÌíà'} ${orderItems.length > 1 ? `Ïô∏ ${orderItems.length - 1}Í∞ú` : ''} Ï£ºÎ¨∏`,
                customerName: selectedAddress.name || 'ÌôçÍ∏∏Îèô',
                successUrl: `${window.location.origin}/payments/success`,
                failUrl: `${window.location.origin}/payments/failure`,
            })
        } catch (e) {
            console.error(e)
            alert('Í≤∞Ï†ú Ïã§Ìå®')
        }
    }

    // ----- load checkout from localStorage -----
    useEffect(() => {
        // localStorageÎäî ÌÅ¥ÎùºÏóêÏÑúÎßå Ï†ëÍ∑º Í∞ÄÎä•
        const raw = typeof window !== 'undefined' ? localStorage.getItem('checkout') : null
        if (!raw) return
        try {
            const parsed: CheckoutRow[] = JSON.parse(raw)
            setCheckout(parsed)
        } catch (e) {
            console.error('checkout ÌååÏã± Ïã§Ìå®', e)
        }
    }, [])

    // ----- fetch products in batch & build orderItems -----
    useEffect(() => {
        if (!checkout.length) return
            ; (async () => {
                try {
                    const ids = checkout.map(c => c.productId)
                    const { data } = await requester.post('/api/products', { ids })
                    const results = data.results as (IProduct | null)[]

                    const items: OrderItem[] = results.flatMap((p, i) =>
                        p
                            ? [{
                                productId: p.id,
                                price: p.price,
                                quantity: checkout[i].quantity,
                                thumbnail_image: p.thumbnailImage,
                                deliveryType: checkout[i].deliveryMethod,
                                kor_name: p.korName,
                                eng_name: p.engName,
                            }]
                            : []
                    )

                    setOrderItems(items)
                    // ÌïÑÏöî Ïãú ÏÑ±Í≥µ ÌéòÏù¥ÏßÄÏö©ÏúºÎ°ú Î≥¥Ï°¥
                    sessionStorage.setItem('orderItems', JSON.stringify(items))
                } catch (e) {
                    console.error('batch fetch failed:', e)
                }
            })()
    }, [checkout])

    // ----- fetch default address -----
    useEffect(() => {
        (async () => {
            try {
                const res = await requester.get('/api/addresses');
                const addresses: AddressDto[] = res.data;
                const def = addresses.find(a => a.isDefault);
                if (def) {
                    const zip =
                        (def as AddressDto & { postalCode?: string; postCode?: string; zipcode?: string; zipCode?: string; zonecode?: string }).postalCode ??
                        (def as AddressDto & { postalCode?: string; postCode?: string; zipcode?: string; zipCode?: string; zonecode?: string }).postCode ??
                        (def as AddressDto & { postalCode?: string; postCode?: string; zipcode?: string; zipCode?: string; zonecode?: string }).zipcode ??
                        (def as AddressDto & { postalCode?: string; postCode?: string; zipcode?: string; zipCode?: string; zonecode?: string }).zipCode ??
                        (def as AddressDto & { postalCode?: string; postCode?: string; zipcode?: string; zipCode?: string; zonecode?: string }).zonecode ?? '';

                    const addr = {
                        id: def.id,
                        name: def.name,
                        phone: def.phone ?? '',
                        fullAddress: formatFullAddress(def),    // ‚úÖ [Ïö∞Ìé∏Î≤àÌò∏] + Ï£ºÏÜå
                        request: def.message ?? '',
                        postalCode: zip || undefined,
                    };
                    setSelectedAddress(addr);
                    sessionStorage.setItem('selectedAddress', JSON.stringify(addr));
                }
            } catch (err) {
                console.error('Ï£ºÏÜå Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®', err);
            }
        })();
    }, []);

    return (
        <main className={styles.checkout_container}>
            <AddressBox
                selectedAddress={selectedAddress ?? null}
                onOpenModal={() => setIsAddressModalOpen(true)}
                onOpenRequestModal={() => setReqOpen(true)}
                onChangeRequest={(req) => {
                    if (!selectedAddress) return
                    setSelectedAddress({ ...selectedAddress, request: req }) // zustand ÏóÖÎç∞Ïù¥Ìä∏
                }}
            />

            {/* Ï£ºÎ¨∏ ÏöîÏïΩ Ïπ¥Îìú: Ïó¨Îü¨ ÏÉÅÌíà Î†åÎçîÎßÅÌïòÎäî Î≤ÑÏ†Ñ ÏÇ¨Ïö© */}
            <OrderSummaryCard
                orderItems={orderItems}
                deliveryType={deliveryType}
                onChangeDelivery={(t) => {
                    setDeliveryType(t)
                    setDeliveryFee(t === 'FAST' ? 5000 : 0)
                }}
                totalPrice={totalPrice}
            />

            <PointSection
                availablePoints={100000 /* Î≥¥Ïú† Ìè¨Ïù∏Ìä∏ */}
                maxUsablePoints={totalBeforePoints}              // üî• Ï∂îÍ∞Ä
                onChange={(p) => setPoints(Math.max(0, Math.min(p, totalBeforePoints)))} // üî• Ï∫° Ï†ÅÏö©
            />

            <FinalOrderSummary
                price={priceWithoutDelivery}
                fee={0}
                shippingFee={deliveryFee}
                couponAmount={0}
                pointAmount={points}
            />

            <PaymentFooter totalPrice={totalPrice} onPay={handlePayment} />

            {isAddressModalOpen && (
                <AddressModal
                    onClose={() => setIsAddressModalOpen(false)}
                    selectedAddress={selectedAddress ? {
                        ...selectedAddress,
                        request: selectedAddress.request
                    } : null}
                    onChangeSelected={(a) => {
                        const zip =
                            (a as unknown as AddressDtoWithPostalFields).postalCode ??
                            (a as unknown as AddressDtoWithPostalFields).postCode ??
                            (a as unknown as AddressDtoWithPostalFields).zipcode ??
                            (a as unknown as AddressDtoWithPostalFields).zipCode ??
                            (a as unknown as AddressDtoWithPostalFields).zonecode ?? '';

                        if (!a?.id) return; // Early return if no valid address

                        const mapped = {
                            id: a.id,
                            name: a.name ?? '',
                            phone: a.phone ?? '',
                            fullAddress: a.fullAddress ?? '',
                            request: a.request ?? '',
                            postalCode: zip || undefined,
                        };
                        setSelectedAddress(mapped);
                        sessionStorage.setItem('selectedAddress', JSON.stringify(mapped));
                    }}
                />
            )}

            <RequestModal
                open={isReqOpen}
                value={selectedAddress?.request ?? ''}
                onClose={() => setReqOpen(false)}
                onApply={(next) => {
                    if (!selectedAddress) return;
                    const updated = { ...selectedAddress, request: next };
                    setSelectedAddress(updated);
                    sessionStorage.setItem('selectedAddress', JSON.stringify(updated));
                }}
            />
        </main>
    )
}
